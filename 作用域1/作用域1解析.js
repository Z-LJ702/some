//  首先，if 里面的 function a(){} 会声明提升
//  将声明" var a" 移到函数级作用域最前面，将函数定义移到块级作用域最前面
//  预解析如下
var a;// 函数 a 的声明提前 
var a = 0;  // 已经声明了 a，这里会忽略声明 ,直接赋值为 0 相当于 a = 0 
if(true){
    function a(){} // 函数定义 a 声明提升到块级最前面
    a = 1; // 这里将 块级作用域最前面的函数 a 重置为 1了。
    // function a(){};  how do ？
    a = 21;
    console.log("里面",a);
}
console.log("外部",a);

//  ****函数本身是【 定义函数名变量 指针指向 函数内存块】。
//  函数提升是在块级作用域，但是函数名变量是函数级别的作用域。
//  所以在块级的函数定义（原始代码函数的声明位置）的时候，会将函数名变量同步到函数级作用域，
//  实际上，只有这个时候，在块级作用域外才能访问到函数定义。****
//  预解析如下

//  函数提升优先级比变量提升要高, 函数提升在 块级作用域 内提升, 函数的定义会在块级作用域和函数级作用域内同步
var a = 0;
if(true){
    console.log(a,window.a);// 函数提升，是块级作用域，输出 function a 和 0
    a = 1;  // 取作用域最近的块级作用域的 function a ,且被重置为 1了，本质又是一个 变量的赋值。
    console.log(a,window.a);// a 是指向块级作用域的 a, 输出 1 和 0 
    function a(){} 
    // ****函数的声明，将执行函数的变量的定义同步到函数级的作用域****。
    //  函数变量不会被普通变量声明覆盖，但是会被变量赋值覆盖, 先声明的普通变量优先级低于同名函数变量声明 
    //  同名函数变量会覆盖先声明的普通变量
    //  1.如果此时函数变量未进行 a = 1 的赋值操作 
    //  那么函数定义只会使函数变量a覆盖上面变量a window.a = func a() {}
    //  2.而此时函数声明时 函数变量a进行了赋值操作 a = 1 那么上面变量a被函数变量a覆盖 a = 1
    console.log(a,window.a);// 输出 1 和 1  => window.a = function a = 1
    a = 21; // 仍然是函数定义块级作用域的 a ,重置为 21
    console.log(a,window.a); // 输出为函数提升的块级作用域的 a, 输出 21，1
    console.log("里面",a);
}
console.log("外部",a);

//  内部的函数 function a(){} 在预解析的时候 
//  1.会把函数变量a声明 var a 提升到函数级作用域的最前面 即var a = 0的前面 
//  此时未定义块级函数 a依然是普通变量 等待定义 var a = 0 由于前面已声明 变为赋值 a = 0
//  在块级函数未定义之前 window.a访问的是普通变量 
//  2.会把函数变量a的函数定义声明function a(){} 提升到块级作用域的最顶端 即if(){}内部最顶端
//  3.在块级函数定义(原始代码函数的声明位置)的时候 会将函数名变量同步到函数级作用域 a = 0被覆盖为func a(){}
//  而此时函数变量a已经被赋值 a = 1 那么就将 a = 1同步到函数级作用域 